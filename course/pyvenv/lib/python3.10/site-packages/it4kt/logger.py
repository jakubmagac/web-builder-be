from typing import Any, NoReturn, Tuple, IO, Optional
import click
import logging
import sys


class ColoredFormatter(logging.Formatter):
    def __init__(self, msg, use_color=True):
        logging.Formatter.__init__(self, msg)
        self.use_color = use_color

    def _colorize_level(self, level) -> str:
        if level == "NOTSET":
            return "[NOTSET]"
        if level == "DEBUG":
            return click.style("[DEBUG]", fg="blue", bold=True)
        if level == "INFO":
            return click.style("[INFO]", fg="cyan", bold=True)
        if level == "WARNING":
            return click.style("[WARNING]", fg="yellow", bold=True)
        if level == "ERROR":
            return click.style("[ERROR]", fg="red", bold=True)
        if level == "CRITICAL":
            return click.style("[CRITICAL]", fg="red", bold=True)

        raise Exception(
            "LoggerManager: Following unsupported Log type was provided: '{}'.".format(
                level
            )
        )

    def format(self, record):
        levelname = record.levelname
        if self.use_color:
            levelname_color = self._colorize_level(levelname)
            record.levelname = levelname_color
        return logging.Formatter.format(self, record)


class LoggerManager:
    """
    Custom simplified logging system. Logs are only printed in console
    so no log files are allowed with this implementation. Serves to
    inform users about convertor related events.
    """

    __instance = None

    def __init__(self):
        if LoggerManager.__instance:
            raise Exception(
                "Do not create LoggerManager instance on your own!"
                " Use already created instance 'logger' instead!"
            )

        # save instance so no other instance is allowed to be created
        LoggerManager.__instance = self

        self._enabled = True
        self._initialize_logger()

    def _initialize_logger(self, output_to: Optional[IO[str]] = sys.stdout):
        self._logger = logging.getLogger("it4kt-builder")
        self._logger.setLevel(logging.INFO)

        self._logger_handler = logging.StreamHandler(stream=output_to)
        self._logger.addHandler(self._logger_handler)
        # We are customizing colors for log level
        formatter = ColoredFormatter("%(levelname)s %(message)s")
        self._logger_handler.setFormatter(formatter)

    def set_output_destination(self, output_to: Optional[IO[str]]):
        self._initialize_logger(output_to)

    def enable(self) -> None:
        self._enabled = True

    def disable(self) -> None:
        self._enabled = False

    def set_level(self, level):
        self._logger.setLevel(level)

    def _parse_trace(self, frame_offset: int = 3) -> Tuple[str, str, int]:
        """
            Method will lookup to stack trace and pick relevant call for logging purposes.

            @param frame_offset - How much method is offset from origin method
                that is trying to log something? Minimal offset value is 3 because when
                any class method is calling this method it means that at least 3 methods
                are called during logging call.
        """
        blame_frame = sys._getframe(frame_offset)
        blame_filename = blame_frame.f_code.co_filename
        blame_method = blame_frame.f_code.co_name
        blame_line = blame_frame.f_lineno

        # dir_path = os.path.dirname(os.path.abspath(__file__)) + "/"
        # filename_stripped = blame_filename.replace(dir_path, "")

        return blame_filename, blame_method, blame_line

    def _log(self, logtype: int, message: str, verbose: bool = False):
        if not self._enabled and logtype != logging.CRITICAL:
            # if logging is disabled
            return

        parsed_message = message
        if verbose:
            filename, method, line = self._parse_trace()
            parsed_message = ("File: '{file}'"
                              "\n  Called at line: {line}"
                              "\n  By function: '{method}()"
                              "\n  With message: '{message}'").format(
                file=filename, method=method, line=line, message=message
            )

        self._logger.log(msg=parsed_message, level=logtype)

    def info(self, msg: str):
        """
        Informational message.

        @param msg - Message, which is going te bo displayed.
        """
        self._log(logging.INFO, msg)

    def debug(self, msg: str):
        """
        Just a debugging message.

        @param msg - Message, which is going te bo displayed.
        """
        self._log(logging.DEBUG, msg)

    def warning(self, msg: str, verbose: bool = False):
        """
        Displays some kind of warning.

        @param msg - Message, which is going te bo displayed.
        @param verbose - If True, logger is going to provide additional
            details about the place of log call including file name,
            method name and line of code.
        """
        self._log(logging.WARNING, msg)

    def error(self, msg: str, verbose: bool = False):
        """
        If you are logging an Error, you are logging a situation which
        has not ended by your expectations but the program is able to
        recover itself and continue the execution.

        @param msg - Message, which is going te bo displayed.
        """
        self._log(logging.ERROR, msg, verbose)

    def critical(self, msg: str, rt=1) -> NoReturn:
        """
        Logging as CRITICAL means that program execution is going to
        be stopped as soon as message is logged. Critical log is always
        going to be verbose.

        @param msg - Message, which is going te bo displayed.
        """
        self._log(logging.CRITICAL, msg, verbose=True)
        sys.exit(rt)

    def exception(self, exception: Any):
        self._logger.exception(exception)


# Create a singleton instance which is going to be used across the project.
logger = LoggerManager()
