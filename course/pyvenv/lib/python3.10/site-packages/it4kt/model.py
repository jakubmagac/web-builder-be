"""
All course artifacts are stored in the Course object. They consist from Pages
grouped into Folders. Folders correspond to different groups of artifacts:
lectures, labs, assignments, etc.
"""
import copy
import itertools
from collections import OrderedDict
from pathlib import PurePath
from typing import Iterable, List, Optional, Tuple, Dict

from lxml import html

import it4kt

COURSE_OVERVIEW = 'overview'
OBJECTIVES_OVERVIEW = 'objectives_overview'


class Course:
    """Course contains a collection of folders and top-level pages.
    Other attributes of course:
    - title -- full name of the course
    - acronym -- shortened name of the course
    """
    url = '.'

    def __init__(self, title: str, acronym: Optional[str] = None):
        self.title = title
        self.acronym = acronym or make_acronym(title)
        self._pages: OrderedDict[PurePath, "Page"] = OrderedDict()
        self._folders: OrderedDict[PurePath, "Folder"] = OrderedDict()
        self.links: List['Link'] = []

    @property
    def pages(self) -> Iterable['Page']:
        """Top-level pages of the course."""
        return sorted(self._pages.values(),
                      key=lambda p: (p.path.stem != 'index', p.path.name))

    @property
    def folders(self) -> Iterable['Folder']:
        """List of folders of the course."""
        return self._folders.values()

    @property
    def menu(self) -> Iterable['MenuItem']:
        """Course folders, pages and other links that should be displayed in
        the menu."""
        return filter(lambda i: i.title is not None,
                      itertools.chain(self.pages, self.folders, self.links))

    @property
    def course_overview(self) -> 'Overview':
        return self.get_overview(PurePath(COURSE_OVERVIEW))

    @property
    def objectives_overview(self) -> 'Overview':
        return self.get_overview(PurePath(OBJECTIVES_OVERVIEW))

    def put_pages(self, pages: Iterable['Page']) -> None:
        for page in pages:
            self._pages[page.path] = page

    def put_folders(self, folders: Iterable['Folder']) -> None:
        for folder in folders:
            self._folders[folder.path] = folder

    def get_overview(self, path: PurePath):
        overview = Overview(path, self.folders)
        return overview

    def put_links(self, links: List['Link']) -> None:
        self.links = links.copy()

    def get_by_path(self, path: PurePath) -> 'Page':
        if path in self._pages:
            return self._pages[path]
        else:
            return self._folders[path.parent].get_by_path(path)


class MenuItem:
    """Base class for menu items. In addition to url and subitems,
    each MenuItem should have title property."""
    title: Optional[str]

    @property
    def url(self) -> Optional[str]:
        """URL for the link, or None if it is a submenu."""
        return None

    @property
    def subitems(self) -> Optional[Iterable['MenuItem']]:
        """Items of a submenu, or None if it is a direct link."""
        return None

    def translated_url(self, lang: str) -> Optional[str]:
        if self.url is None:
            return None
        go_up = "../" if it4kt.i18n.language != it4kt.i18n.default_lang else ""
        go_lang = lang + "/" if lang != it4kt.i18n.default_lang else ""
        return go_up + go_lang + self.url

    def is_homepage(self) -> bool:
        return self.url == 'index.html'

    def is_folder(self) -> bool:
        return False

    def is_external(self) -> bool:
        return False

    def is_hidden(self) -> bool:
        return False


class Folder(MenuItem):
    """A folder is a collection of pages."""

    def __init__(self, path: PurePath, title: Optional[str]):
        self.path = path
        self.title = title
        self._pages: Dict[PurePath, "Page"] = {}

    @property
    def subitems(self) -> Iterable["Page"]:
        return sorted(self._pages.values(), key=sorting_key)

    def is_folder(self) -> bool:
        return True

    def put_pages(self, pages: Iterable['Page']) -> None:
        for page in pages:
            self._pages[page.path] = page

    def get_by_path(self, path: PurePath) -> 'Page':
        page = self._pages[path]
        if page.is_hidden():
            raise KeyError('Page is hidden in this mode')
        return page


class Page(MenuItem):
    """A single page. Content is a HTML formatted text."""

    def __init__(self, path: PurePath):
        self.path = path
        self.title: str = ""
        self.subtitle: str = ""
        self.week: Optional[int] = None
        self._publication_week: Optional[int] = None
        self._student_content: Optional[html.HtmlElement] = None
        self._lecturer_content: Optional[html.HtmlElement] = None

    @property
    def element_tree(self) -> Optional[html.HtmlElement]:
        if it4kt.env.lecturer_mode:
            return self._lecturer_content
        else:
            return self._student_content

    @element_tree.setter
    def element_tree(self, content: html.HtmlElement):
        self._lecturer_content = content
        self._student_content = self._make_student_content()

    @property
    def content(self) -> Optional[str]:
        if it4kt.env.lecturer_mode:
            return self.lecturer_content
        else:
            return self.student_content

    @property
    def student_content(self) -> str:
        if self._student_content is None:
            return ""
        return html_to_string(self._student_content)

    @property
    def lecturer_content(self) -> str:
        if self._student_content is None:
            return ""
        return html_to_string(self._lecturer_content)

    def get_objectives(self) -> List[str]:
        if self._student_content is not None:
            objectives = self._student_content.xpath("//li[contains(@class, 'objective')]")
            return [inner_html(objective).strip() for objective in objectives]
        else:
            return []

    @property
    def url(self) -> str:
        return self.path.with_suffix('.html').as_posix()

    @property
    def url_without_suffix(self) -> str:
        return self.path.with_suffix('').as_posix()

    @property
    def publication_week(self) -> int:
        if self._publication_week is not None:
            return self._publication_week
        elif self.week is not None:
            return self.week
        else:
            return 1

    @publication_week.setter
    def publication_week(self, value: int) -> None:
        self._publication_week = value

    def is_hidden(self) -> bool:
        if it4kt.env.published_weeks is None:
            return False
        elif it4kt.env.lecturer_mode:
            return False
        else:
            return self.publication_week > it4kt.env.published_weeks

    def __repr__(self):
        return f'Page({self.path})'

    def _make_student_content(self):
        student_content = copy.deepcopy(self._lecturer_content)
        for element in student_content.find_class('lecturer'):
            element.getparent().remove(element)
        return student_content


class SlidePage(Page):
    def __init__(self, path: PurePath):
        super().__init__(path)
        self.theme: str = 'material'
        self.aspect_ratio = '16/10'


class Link(MenuItem):
    def __init__(self, title: str, url: str):
        self.title = title
        self._url = url

    @property
    def url(self) -> str:
        return self._url

    def is_external(self) -> bool:
        return True


class Overview(MenuItem):
    """Overview of the course."""
    week = None

    def __init__(self, path: PurePath, folders: Iterable[Folder]):
        self.path = path
        self.folders: OrderedDict[Folder, Iterable[Page]] = OrderedDict()
        self._add_folders(folders)

    def _add_folders(self, folders: Iterable[Folder]) -> None:
        if folders is None:
            return
        for folder in folders:
            if folder.title is None:
                continue
            self.folders[folder] = folder.subitems

    @property
    def url(self) -> str:
        return str(self.path.with_suffix('.html'))


def make_acronym(title: str) -> str:
    """Make acronym of a course title."""
    words = title.split()
    acronym = ''
    for word in words:
        initial = word[0]
        if len(word) > 1:
            initial = initial.upper()
        acronym += initial
    return acronym


def sorting_key(page: Page) -> Tuple[int, str]:
    """Create a key for sorting pages."""
    if page.week is not None:
        week = page.week
    else:
        week = 100  # Just a number larger then possible week numbers
    filename = page.path.name
    return week, filename


def html_to_string(element: html.HtmlElement) -> str:
    # If root element has "unwrap" class, return only its children
    if 'unwrap' in element.classes:
        return inner_html(element)
    return html.tostring(element, encoding='unicode')


def inner_html(element: html.HtmlElement) -> str:
    leading_text = element.text or ''
    children = [html_to_string(child) for child in element.iterchildren()]
    return leading_text + ''.join(children)
