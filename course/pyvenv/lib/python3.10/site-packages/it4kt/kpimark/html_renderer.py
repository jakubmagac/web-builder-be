import itertools
from typing import List, Union

from markupsafe import Markup
from mistletoe.block_token import BlockToken
from mistletoe.html_renderer import HTMLRenderer, html
from mistletoe.span_token import SpanToken

from it4kt import i18n


class KpimarkHTMLRenderer(HTMLRenderer):
    TOKENS_EXTENDED: List[Union[BlockToken, SpanToken]] = []

    def __init__(self, custom_tokens):
        super().__init__(*itertools.chain(custom_tokens, self.TOKENS_EXTENDED))
        self.title = None
        self.subtitle = None
        self.author = None
        self.week = None
        self.publication_week = None
        self._init_counters()

    def _init_counters(self):
        self.counters = Counters()
        self.counters.new("figure")
        self.counters.new("step")
        self.counters.new("task", ["step"])

    def strip_template(self, str):
        """
        We are using Python templates to make rendering prettier but sometimes
        we need to strip all whitespaces from final string in order to prevent
        unwanted whitespaces to make it into a final document.

        Following method will strip all whitespaces from template.

        Warning: Use it only for templates. Do not use method for converted strings
        because it will also delete inner whitespaces which should have its meaning.
        """
        return str.replace("    ", "").replace("\n", "").replace("\t", "")

    def render_html(self, token):
        return """
        <div class="page-contents">
            {body}
        </div>
        """.format(
            body=self.render(token)
        )

    def render_meta_block(self, token):
        self.title = token.meta.get("title")
        self.subtitle = token.meta.get("subtitle")
        self.author = token.meta.get("author")
        self.week = token.meta.get("week")
        self.publication_week = token.meta.get("publication_week")
        # meta token doesn't provide any HTML DOM data so we can return
        # just an empty string to purge meta-data content from final doc.
        return ""

    def render_section_block(self, token, header=None, body=None, block_type="section"):
        template = """<section class="section section--{block_type}">
            <h2 class="section__header">{header}</h2>
            {body}
        </section>"""

        if not header:
            header = "".join(map(self.render, token.keyword))
        if not body:
            body = "\n".join([self.render(child) for child in token.children])

        return template.format(block_type=block_type, header=header, body=body)

    def render_instructions_block(self, token):
        header = i18n.t("builder:instructions")
        return self.render_section_block(token, header=header, block_type="instructions")

    def render_introduction_block(self, token):
        header = i18n.t("builder:introduction")
        return self.render_section_block(token, header=header, block_type="introduction")

    def render_step_block(self, token):
        self.counters.step("step")
        template = """
        <section class="step"
        {data_objectives} id="step-{step}">
            <h3 class="step__header{title_style}">
                <span class="step__keyword">{keyword} </span>
                <span class="step__number">{step}</span>
                {title_content}
            </h3>
            {body_content}
        </section>"""

        objectives_template = 'data-objectives="objective-{obj}"'
        objectives = ""
        if token.objectives is not None:
            list_objectives = token.objectives.split()
            objectives = " objective-".join(list_objectives)
            objectives = objectives_template.format(obj=objectives)

        title_content_template = """
            <span class="step__colon">{colon}</span>
            <span class="step__title">{title}</span>
        """

        if token.title:
            title = token.title
            colon = ": "
            title_style = " step__header--with-title"
            title_content = self.strip_template(title_content_template).format(
                colon=colon, title="".join(map(self.render, title))
            )
        else:
            title_style = " step__header--without-title"
            title_content = ""

        return self.strip_template(template).format(
            data_objectives=objectives,
            title_style=title_style,
            step=self.counters.get("step"),
            keyword=i18n.t("builder:step"),
            title_content=title_content,
            body_content=self.render_inner(token),
        )

    def render_objectives_block(self, token):
        template = """<ol class="objectives">
            {content}
        </ol>"""
        content = self.render_inner(token)
        body = template.format(content=content)

        header = i18n.t("builder:objective_plural")
        return self.render_section_block(token, body=body, header=header, block_type="objectives")

    def render_objective_item(self, token):
        li_template = '<li class="objective" {id}>{content}</li>'
        id_template = 'id="objective-{}"'

        inner = " ".join([self.render(child) for child in token.children])
        _id = id_template.format(token.id) if token.id else ""

        return li_template.format(content=inner, id=_id)

    def render_summary_block(self, token):
        header = i18n.t("builder:summary")
        return self.render_section_block(token, header, block_type="summary")

    def render_additional_resources_block(self, token):
        header = i18n.t("builder:additionalResources")
        return self.render_section_block(token, header, block_type="additional-resources")

    def render_additional_tasks_block(self, token):
        self.counters.set("step", "A")
        header = i18n.t("builder:additionalTasks")
        return self.render_section_block(token, header, block_type="additional-tasks_block")

    def render_resources_block(self, token):
        header = i18n.t("builder:resources")
        return self.render_section_block(token, header, block_type="resources")

    def render_admonition(self, token, alert_type, body=None, stepper="",
                          heading=None, is_hidden=False, footer="", heading_title=""):
        template = """<div class="admonition admonition--{type}">
            <h4 class="admonition__header">{heading}{stepper}</h4>{heading_title}
            <div class="admonition__content{is_hidden}">{body_content}</div>
            {footer}
        </div>"""

        return template.format(
            type=alert_type,
            heading=heading if heading else token.keyword,
            heading_title=heading_title,
            body_content=body if body else self.render_inner(token),
            stepper=stepper,
            is_hidden=" hidden" if is_hidden else "",
            footer=footer

        )

    def render_task_block(self, token):
        self.counters.step("task")
        template = """<div class="task">
            <h4 class="task__header">{heading}{stepper}</h4>
            <div class="task__content">{content}</div>
        </div>"""

        steper_template = ' <span class="task__number">{step}.{task}</span>'
        stepper = steper_template.format(
            step=self.counters.get("step"), task=self.counters.get("task"))

        header = i18n.t("builder:task")
        return template.format(
            heading=header, content=self.render_inner(token), stepper=stepper
        )

    def render_warning_block(self, token):
        heading = i18n.t("builder:warning")
        return self.render_admonition(token, "warning", heading=heading)

    def render_note_block(self, token):
        heading = i18n.t("builder:comment")
        return self.render_admonition(token, "note", heading=heading)

    def render_example_block(self, token):
        heading = i18n.t("builder:example")
        return self._render_titled_example(token, heading)

    def render_wrong_example_block(self, token):
        heading = i18n.t("builder:wrongExample")
        return self._render_titled_example(token, heading, " example--wrong")

    def _render_titled_example(self, token, heading, modifier=""):
        content = self.render_inner(token)
        if token.title:
            return f"""<div class="example{modifier}">
                <h4 class="example__header">{heading}:
                  <span class="example__title">{token.title}</span></h4>
                <div class="example__content">{content}</div>
            </div>"""
        else:
            return f"""<div class="example{modifier}">
                <h4 class="example__header">{heading}</h4>
                <div class="example__content">{content}</div>
            </div>"""

    def render_lecturer_block(self, token):
        template = """<div class="lecturer">
            <h4 class="lecturer__header">{header}</h4>
            <div class="lecturer__content">{content}</div>
        </div>"""

        header = i18n.t("builder:lecturer")
        return template.format(header=header, content=self.render_inner(token))

    def render_solution_block(self, token, heading=None):
        template = """<div class="solution{hideable}">
            <h4 class="solution__header">{heading}</h4>
            <div class="solution__content">{content}</div>
        </div>"""

        return template.format(
            heading=heading if heading else i18n.t("builder:solution"),
            content=self.render_inner(token),
            hideable=" solution--hideable" if token.is_hidden else ""
        )

    def render_result_block(self, token):
        heading = i18n.t("builder:result")
        return self.render_solution_block(token, heading)

    def render_math(self, token):
        return '<span class="math">' + token.content + '</span>'

    def render_block_code(self, token):
        if not token.children[0].content.strip():
            return ""

        template = '<pre class="code"><code{attr}>{inner}</code></pre>'
        if token.language:
            attr = ' class="{}"'.format(
                "language-{}".format(html.escape(token.language))
            )
        else:
            attr = ""
        inner = html.escape(token.children[0].content)
        return template.format(attr=attr, inner=inner)

    def render_table(self, token):
        # for documentation check HTMLRenderer's render_table method.
        template = (
            '<div class="table"><table class="table__table">\n{inner}</table></div>'
        )
        if hasattr(token, "header"):
            head_template = "<thead>\n{inner}</thead>\n"
            head_inner = self.render_table_row(token.header, is_header=True)
            head_rendered = head_template.format(inner=head_inner)
        else:
            head_rendered = ""
        body_template = "<tbody>\n{inner}</tbody>\n"
        body_inner = self.render_inner(token)
        body_rendered = body_template.format(inner=body_inner)
        return template.format(inner=head_rendered + body_rendered)

    def render_image(self, token):
        self.counters.step("figure")
        template = """<figure class="figure">
            <img src="{src}" alt="{alt}" />
            <figcaption>{caption}</figcaption>
        </figure>"""

        alt = self.render_inner(token)
        fig_prefix = i18n.t('builder:imgFigure')
        caption_text = alt
        if token.title:
            caption_text = token.title
        number = self.counters.get("figure")
        if caption_text:
            caption = (
                f'<span class="figure__number">{fig_prefix} {number}:</span> '
                f'<span class="figure__caption">{caption_text}</span>')
        else:
            caption = f'<span class="figure__number">{fig_prefix} {number}</span>'
        stripped_alt = Markup.escape(Markup(alt).striptags())
        return template.format(alt=stripped_alt, src=token.src, caption=caption)

    def render_media_token(self, token, content, _type):
        template = """<div class="media media--{type}">
            <figure>
                <div class="media__container">
                {body}
                </div>
                <figcaption>{caption}</figcaption>
            </figure>
        </div>"""

        alt = self.render_inner(token)
        if token.title:
            caption = "{}".format(html.escape(token.title))
        else:
            caption = "{}".format(alt if alt else "")

        return template.format(body=content, caption=caption, type=_type)

    def render_youtube_token(self, token):
        template = (
            '<iframe class="media__iframe"'
            ' src="https://www.youtube.com/embed/{src}"></iframe>')
        return self.render_media_token(token, template.format(src=token.src), "youtube")

    def render_video_token(self, token):
        template = """<video class="media__video" controls>
            <source src="{src}" type="video/{type}">
        </video>"""

        return self.render_media_token(
            token, template.format(src=token.src, type=token.type), "video"
        )

    def render_audio_token(self, token):
        template = """<audio class="media__audio" controls>
            <source src="{src}" type="audio/{type}">
        </audio>"""

        audio_type = "mpeg" if token.type == "mp3" else token.type
        return self.render_media_token(
            token, template.format(src=token.src, type=audio_type), "audio"
        )


class Counters:
    """Counters for page elements. Multiple named counters can be defined."""
    def __init__(self):
        self._counters = {}
        self._children = {}

    def new(self, name, reset_on=None):
        """Add a new counter.
        Use reset_on to list parent counters that would reset this one.
        """
        self._counters[name] = 0
        self._children[name] = []
        if reset_on is not None:
            for parent in reset_on:
                self._children[parent].append(name)

    def get(self, name):
        return self._counters[name]

    def step(self, name):
        """Increment counter value (if it is numeric)."""
        try:
            value = self._counters[name]
            self.set(name, value + 1)
        except TypeError:
            pass  # Don't increment counters that are not numeric

    def set(self, name, value):
        self._counters[name] = value
        for counter in self._children[name]:
            self.reset(counter)

    def reset(self, name):
        self.set(name, 0)
