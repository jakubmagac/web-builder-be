import re

from mistletoe import span_token, block_tokenizer
from mistletoe.block_token import BlockToken, CodeFence, HTMLBlock, _token_types
from mistletoe.span_token import tokenize_inner


class SectionBlock(BlockToken):
    pattern = re.compile(r"^##\s+(?P<keyword>.*)$", re.I)

    def __init__(self, match):
        header, parse_buffer = match
        self.keyword = span_token.tokenize_inner(header["keyword"])
        self.children = block_tokenizer.make_tokens(parse_buffer)

    @classmethod
    def start(cls, line, matching_strings=[]):
        m = cls.pattern.search(line)
        if not m:
            return False

        keyword = m.group("keyword")
        lower_keyword = keyword.lower()
        lower_m_strings = [key.lower() for key in matching_strings]

        if not matching_strings or lower_keyword in lower_m_strings:
            return True

        return False

    @classmethod
    def read(cls, lines):
        header_m = cls.pattern.search(next(lines))
        header = {"keyword": header_m.group("keyword")}

        line_buffer = []
        next_line = lines.peek()
        while next_line is not None and not cls.pattern.search(next_line):
            if not cls.search_fenced_block(lines, line_buffer) \
                    and not cls.search_html_block(lines, line_buffer):
                # no other tokens, we're good
                line_buffer.append(next(lines))
            next_line = lines.peek()

        return cls.read_with_footnotes(header, line_buffer)

    @staticmethod
    def search_fenced_block(lines, line_buffer):
        """
        Following need was raised as section block is ending whenever any other
        section is started. In start() method raw lines of text are assigned to
        token so we need to check if another false "section" isn't located inside
        code block.

        This edge case should only arise when markdown language is parsed but to
        be sure that renderer will handle all cases correctly we are searching for
        fenced code block in every language.
        """
        next_line = lines.peek()
        if next_line and CodeFence.start(next_line):
            matched_lines, [_, _, lang] = CodeFence.read(lines)
            line_buffer.append("```{}".format(lang or ""))
            line_buffer += matched_lines
            line_buffer.append("```")
            return True

        return False

    @staticmethod
    def search_html_block(lines, line_buffer):
        """ Another edge case can arise when section block is commented using HTML
            comment.
        """
        next_line = lines.peek()
        if next_line and HTMLBlock.start(next_line):
            html_buffer = HTMLBlock.read(lines)
            line_buffer += html_buffer
            return True

        return False

    @staticmethod
    def read_with_footnotes(header, line_buffer):
        # For Footnotes-like link to work we need to use
        # tokenize_block from here.
        parse_buffer = block_tokenizer.tokenize_block(line_buffer, _token_types)
        return header, parse_buffer


class InstructionsBlock(BlockToken):
    def __init__(self, children):
        self.children = children

    @classmethod
    def start(cls, line):
        # This block isn't part of parsing.
        # All Steps block are going to be wrapped inside this block
        # so we return False
        return False

    @classmethod
    def read_tokens(cls, tokens):
        first_step_index = None
        last_step_index = None
        for token in tokens:
            if isinstance(token, StepBlock):
                token_index = tokens.index(token)
                if first_step_index is None:
                    first_step_index = token_index

                last_step_index = token_index

        if first_step_index is None or last_step_index is None:
            return tokens

        instruction_token = cls(tokens[first_step_index:last_step_index + 1])

        return (
            tokens[:first_step_index]
            + [instruction_token]
            + tokens[last_step_index + 1:]
        )


class IntroductionBlock(SectionBlock):
    """Introduction Block"""

    @classmethod
    def start(cls, line):
        return super().start(line, ["introduction", "úvod"])


class ObjectivesBlock(SectionBlock):
    def __init__(self, match):
        keyword, matches = match

        self.keyword = keyword
        self.children = []
        for item in matches:
            if isinstance(item, dict) and item.get("text") is not None:
                self.children.append(ObjectiveItem(item["text"], item["id"]))
            else:
                self.children += tokenize_inner(item)

    @classmethod
    def start(cls, line):
        return super().start(line, ["objectives", "ciele"])

    @classmethod
    def read(cls, lines):
        # # get keyword from header line
        header_match = cls.pattern.search(next(lines))
        keyword = header_match.group("keyword")

        line_buffer = []
        next_line = lines.peek()
        while next_line not in [None, ""] and not cls.pattern.search(next_line):
            if next_line == "\n":
                next(lines)
                next_line = lines.peek()
                continue

            if ObjectiveItem.start_line(next_line):
                id, text = ObjectiveItem.read(lines, cls.pattern)
                line_buffer.append({"id": id, "text": text})
            else:
                line_buffer.append(next_line)

            next(lines)
            next_line = lines.peek()

        return keyword, line_buffer


class ObjectiveItem(BlockToken):
    pattern = re.compile(
        r"^[ ]{0,2}(?P<type>(\d+[\.\\)])|-|\*)[ ]+({(?P<id>[\w\-_]+)})?(?P<text>.+?)$",
        re.S,
    )  # re.S -> DOTALL

    def __init__(self, text, _id):
        self.id = _id
        self.children = tokenize_inner(text)

    @staticmethod
    def start(line):
        # ObjectiveItem is not part of normal tokenizing process.
        # These tokens can be created only from ObjectivesBlock class.
        # ... So return False
        return False

    @classmethod
    def start_line(cls, line):
        return cls.pattern.search(line)

    @classmethod
    def read(cls, lines, re_end):
        line = lines.peek()

        match = cls.pattern.search(line)
        if not match:
            next(lines)
            return ""

        id_ = match.group("id")
        text = match.group("text").strip()
        return id_, text


class StepBlock(SectionBlock):
    pattern = re.compile(
        r"^##\s+(?P<keyword>\w+)(:\s+(?P<title>(.*?)))?\s*({(?P<objectives>.*)})?$",
        re.I,
    )

    def __init__(self, match):
        self.keyword = match[0].get("keyword")
        title = match[0].get("title") or ""
        self.title = span_token.tokenize_inner(title)
        self.objectives = match[0].get("objectives")
        super().__init__(match)

    @classmethod
    def start(cls, line):
        return super().start(line, ["step", "krok"])

    @classmethod
    def read(cls, lines):
        header_m = cls.pattern.search(next(lines))
        header = {
            "keyword": header_m.group("keyword"),
            "title": header_m.group("title"),
            "objectives": header_m.group("objectives"),
        }

        line_buffer = []
        next_line = lines.peek()
        while next_line is not None:
            if super().pattern.search(next_line):
                # end when any other block is about to match
                break

            if not cls.search_fenced_block(lines, line_buffer):
                # no other tokens, we're good
                line_buffer.append(next(lines))
            next_line = lines.peek()

        return cls.read_with_footnotes(header, line_buffer)


class SummaryBlock(SectionBlock):
    """Summary Section

    In future we might want to include Quizes inside this section.
    """
    @classmethod
    def start(cls, line):
        return super().start(line, ["summary", "záver"])


class ResourcesBlock(SectionBlock):
    """Resources"""

    @classmethod
    def start(cls, line):
        return super().start(line, ["resources", "zdroje"])


class AdditionalResourcesBlock(SectionBlock):
    """Additional Resources"""

    @classmethod
    def start(cls, line):
        return super().start(line, ["additional resources", "doplňujúce zdroje"])


class AdditionalTasksBlock(SectionBlock):
    """Additional Tasks"""

    @classmethod
    def start(cls, line):
        return super().start(line, ["additional tasks", "doplňujúce úlohy"])
