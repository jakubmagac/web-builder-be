from mistletoe.block_token import BlockToken
import re


class MetaBlock(BlockToken):
    META_KEYS = {
        "title": ["title", "nadpis"],
        "subtitle": ["subtitle", "podnadpis"],
        "author": ["author", "autor"],
        "week": ["week", "týždeň"],
        "publication_week": ["publication-week", "týždeň-zverejnenia"],
        "validation": ["validation", "validácia"],
        "type": ["type", "typ"],
    }

    is_first_line = True
    META_RE = re.compile(r"^[ ]{0,3}(?P<key>[\w\-_]+):\s*(?P<value>.*)", re.I)
    META_MORE_RE = re.compile(r"(?P<tabs>^[ ]{2,})(?P<value>.*)")
    BEGIN_RE = re.compile(r"^-{3}(\s.*)?")
    END_RE = re.compile(r"^(-{3}|\.{3})(\s.*)?")

    def __init__(self, meta_data):
        # span-level tokenizing happens here.
        self.meta = meta_data

    @staticmethod
    def start(line):
        if not MetaBlock.is_first_line:
            return False
        MetaBlock.is_first_line = False

        meta_start = MetaBlock.BEGIN_RE.search(line)
        meta_match = MetaBlock.META_RE.search(line)
        if not meta_start and not meta_match:
            return False

        # meta block has to start at first line
        MetaBlock.is_first_line = False
        return True

    @classmethod
    def read(cls, lines):
        meta_data = {}
        next_line = lines.peek()

        tr_meta_key = None
        while next_line not in [None, "", "\n"]:
            # match "---" starting line
            if cls.BEGIN_RE.search(next_line):
                next(lines)
                next_line = lines.peek()
                continue

            # match "---" ending line
            if cls.END_RE.search(next_line):
                line = next(lines)
                break

            # check if current line is related to the latest key
            appendix_match = cls.META_MORE_RE.search(next_line)
            if appendix_match:
                appendix = appendix_match.group("value")
                if not tr_meta_key:
                    # there is no key saved from previous iteration so we
                    # cannot append this line to any other line
                    raise Exception(
                        "Value: '{}' doesn't match to any related meta key".format(
                            appendix
                        )
                    )

                if isinstance(meta_data.get(tr_meta_key), str):
                    # currently, there is only one item for 'tr_meta_key', so it's a string
                    meta_data[tr_meta_key] = [meta_data[tr_meta_key], appendix]
                else:
                    # 'tr_meta_key' value is already a list so we can append value
                    meta_data[tr_meta_key].append(appendix)

                next(lines)
                next_line = lines.peek()
                continue

            line = next(lines)

            match = cls.META_RE.search(line)
            if match is None:
                break

            meta_key = match.group("key")
            meta_value = match.group("value")
            # get meta key which is used in renderer
            tr_meta_key = cls.get_meta_dict_key(meta_key)
            # set meta
            meta_data[tr_meta_key] = cls.get_value_true_type(meta_value)

            next_line = lines.peek()

        return meta_data

    @staticmethod
    def get_value_true_type(value):
        try:
            val_float = float(value)
            val_int = int(value)
            if val_float != val_int:
                return val_float
            return val_int
        except Exception:
            if isinstance(value, str):
                return value.strip()
            else:
                return value

    @staticmethod
    def get_meta_dict_key(key):
        for tr_key in MetaBlock.META_KEYS.keys():
            unaccented_str = key.lower()
            if unaccented_str in MetaBlock.META_KEYS[tr_key]:
                return tr_key

        return key
