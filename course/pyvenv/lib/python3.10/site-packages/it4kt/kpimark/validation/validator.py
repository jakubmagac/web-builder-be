import itertools
import re
from typing import List, Union

from mistletoe.block_token import Document, BlockToken
from mistletoe.span_token import SpanToken

from it4kt.kpimark.tokens.admonitions import TaskBlock, LecturerBlock
from it4kt.kpimark.tokens.meta import MetaBlock
from it4kt.kpimark.tokens.sections import (
    InstructionsBlock, IntroductionBlock, ObjectivesBlock, AdditionalResourcesBlock)
from it4kt.kpimark.tokens.sections import (
    SectionBlock, ObjectiveItem, StepBlock, SummaryBlock, ResourcesBlock,
    AdditionalTasksBlock)
from it4kt.kpimark.validation.reporter import Reporter
from it4kt.kpimark.validation.shaper import Shape
from it4kt.logger import logger

default_tokens = [
    "Strong",
    "Emphasis",
    "InlineCode",
    "RawText",
    "Strikethrough",
    "Image",
    "Link",
    "AutoLink",
    "EscapeSequence",
    "Heading",
    "SetextHeading",
    "Quote",
    "Paragraph",
    "CodeFence",
    "BlockCode",
    "HTMLSpan",
    "HTMLBlock",
    "HTMLSpan",
    "List",
    "ListItem",
    "Table",
    "TableRow",
    "TableCell",
    "ThematicBreak",
    "LineBreak",
]

document_shape = {
    "scenario": Shape(Document).contains_order(
        [
            Shape(MetaBlock).required,
            Shape(ObjectivesBlock).contains_all_of(ObjectiveItem).required,
            IntroductionBlock,
            Shape(InstructionsBlock).contains_all_of(StepBlock).required,
            SummaryBlock,
            ResourcesBlock,
            AdditionalTasksBlock,
            AdditionalResourcesBlock,
        ]
    ),
    "page": Shape(Document).contains_any_of(
        [
            Shape(MetaBlock).required.first,
            Shape(SectionBlock).multiple,
            ObjectivesBlock,
            ResourcesBlock
        ]
    ),
    "subject_info": Shape(Document).contains_order(
        [
            Shape(MetaBlock).required,
            Shape(ObjectivesBlock).contains_all_of(ObjectiveItem).required,
            Shape(SectionBlock).required.multiple,
            Shape(ResourcesBlock),
        ]
    )
}

lecturer_shape = Shape(LecturerBlock).contains_not([TaskBlock])


class Validator:
    """
    Class which performs validation of tokens starting from a very top - Document
    wrapper token. This validation is performed before specific Renderer renders
    tokens, so it is the right place to perform checks and for example stop
    renderer from rendering somehow wrong or corrupted document.

    Every token has to have it's own validation method which names are statically
    checked and matched. Every validation method can perform multiple validation
    rules checks.

    Rather then performing all the validation rules checks logic here in class
    methods, I've decided to split the logic into a following classes:

    1. Validator   - Match token instance and call specific rule upon the token.
    2. RuleChecker - Define rules and perform rule checking.
    3. Reporter    - Decide how errors and warnings should be handled.
    4. Shaper      - Simple DSL to make tokens content checking easier.

    Validation argument from constructor can contain following values:

    1. "strict" - Every validation error is printed to console.
    2. None - In older version of kpimark this mode was called also
        a "Promiscuisous Mode". No validation rules are checked at all.

    If no 'validation' key is provided, value will fallback to the
    defualt value supplied to constructor of this class.
    """
    TOKENS_EXTENDED: List[Union[BlockToken, SpanToken]] = []
    _parse_name = re.compile(r"([A-Z][a-z]+|[A-Z]+(?![a-z]))")
    LAST_VALIDATED_ADMONITION = None

    def __init__(self, filename, document_type, validation, extras):
        self.filename = filename
        self.validation = validation
        self.document_type = document_type
        self.reporter = Reporter(filename, self.validation)

        self.validate_map = {
            token: self.validate_skip for token in default_tokens}
        self.validate_map["Document"] = self.validate_document  # type: ignore

        self._extras = extras
        for token in itertools.chain(extras, self.TOKENS_EXTENDED):
            try:
                # NOTE: Not every method needs its validation method. If
                # validation method isn't available, set validate_skip
                # to skip validation for specific block!
                validate_func = getattr(self, self._cls_to_func(token.__name__))
                self.validate_map[token.__name__] = validate_func
            except AttributeError:
                self.validate_map[token.__name__] = self.validate_skip

        self.footnotes = {}

    @classmethod
    def _cls_to_func(cls, cls_name):
        snake_case = "_".join(map(str.lower, cls._parse_name.findall(cls_name)))
        return "validate_{}".format(snake_case)

    def validate(self, token):
        """
        Grabs the class name from input token and finds its corresponding
        render function.

        Basically a janky way to do polymorphism.

        Arguments:
            token: whose __class__.__name__ is in self.validate_map
        """
        if type(token) is Document:
            return self.validate_document(token)

        is_valid = True
        if hasattr(token, "children") and isinstance(token.children, list):
            is_valid &= self.validate_inner(token)

        try:
            return self.validate_map[token.__class__.__name__](token) & is_valid
        except Exception:
            logger.warning("Following token has no validation method implemented: '{}'".format(
                token.__class__.__name__))
            return is_valid

    def validate_inner(self, token):
        """
        Recursively validates child tokens. Joins the rendered
        strings with no space in between.

        If newlines / spaces are needed between tokens, add them
        in their respective templates, or override this function
        in the renderer subclass, so that whitespace won't seem to
        appear magically for anyone reading your program.

        Arguments:
            token: a branch node who has children attribute.
        """
        valid = True
        for child in token.children:
            valid &= self.validate(child)

        return valid

    def validate_skip(self, token):
        """
        We don't have a reason to validate default mistletoe blocks
        so we can skip validation for now.
        """
        return True

    def check_meta_validation(self, token):
        """
        If metablock was found it is essential to get 'validation'
        key out of metadata. This key tells RuleChecker, whether
        and how it should perform validation.
        """
        validation = token.meta.get("validation")
        if validation in ["None", "null"]:
            logger.info(("Skipping validation for file "
                         "'{}' completely!").format(self.filename))
            self.validation = None
        elif validation == "strict":
            self.validation = validation
            self.reporter.validation_mode = validation
        elif validation is None:
            pass
        else:
            self.reporter.make_error(
                ("Meta data has 'validation' key set to '{}' but it's "
                 "values can be only 'strict', 'None' or 'null'").format(
                    validation
                )
            )

    def check_meta_document_type(self, token):
        """
            If metablock was found it is essential to get 'validation'
            key out of metadata. This key tells RuleChecker, whether
            and how it should perform validation.
        """
        document_type = token.meta.get("type")
        if document_type in document_shape.keys():
            self.document_type = document_type
            pass
        elif document_type is None:
            pass
        else:
            self.reporter.make_error(
                ("Meta data has 'Template' key set to '{}' but it's "
                 "values can only be one of {}").format(
                    document_type, document_shape.keys()
                )
            )

    def validate_document(self, token):
        # following list should have 0 or 1 items
        meta_tokens = list(filter(lambda x: isinstance(x, MetaBlock), token.children))
        if meta_tokens:
            self.check_meta_validation(meta_tokens[0])
            self.check_meta_document_type(meta_tokens[0])

        if self.validation is None:
            return True

        shape = document_shape.get(self.document_type)
        if shape is None:
            logger.critical(("No validation shape found for "
                             "template named '{}'").format(self.document_type))

        if not shape.check(token, self.reporter):
            return False

        return self.validate_inner(token)

    def validate_meta_block(self, token):
        # check for unsupported meta keys
        meta_keys = MetaBlock.META_KEYS.keys()
        unsupported_keys = []
        for key in token.meta.keys():
            if key not in meta_keys:
                unsupported_keys.append(key)

        if unsupported_keys:
            self.reporter.make_warning(
                "Meta data contains unsupported key/s {} '.".format(unsupported_keys)
            )

        # meta title cannot be None
        if token.meta.get("title") is not None:
            return True

        self.reporter.make_error("Meta doesn't include document's title which is required!")
        return False

    def validate_admonition(self, token):
        self.LAST_VALIDATED_ADMONITION = token.__class__
        # Is admonition nested recursively?
        shape = Shape(token.__class__).contains_not([token.__class__])
        return shape.check(token, self.reporter)

    def validate_task_block(self, token):
        return self.validate_admonition(token)

    def validate_solution_block(self, token):
        is_valid = True
        if self.LAST_VALIDATED_ADMONITION != TaskBlock:
            is_valid = False
            self.reporter.make_error("Solution admonition has to be located right after Task!")

        return is_valid & self.validate_admonition(token)

    def validate_result_block(self, token):
        return self.validate_solution_block(token)

    def validate_warning_block(self, token):
        return self.validate_admonition(token)

    def validate_note_block(self, token):
        return self.validate_admonition(token)

    def validate_example_block(self, token):
        return self.validate_admonition(token)

    def validate_wrong_example_block(self, token):
        return self.validate_admonition(token)

    def validate_lecturer_block(self, token):
        self.validate_admonition(token)
        # is task nested inside lecturer?
        return lecturer_shape.check(token, self.reporter)
