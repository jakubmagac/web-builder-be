from typing import Any, List, Optional, Sequence, Union, Type
from it4kt.kpimark.validation.reporter import Reporter
from mistletoe.block_token import BlockToken
from mistletoe.span_token import SpanToken

TokenType = Union[BlockToken, SpanToken]
TokenClassType = Union[Type[BlockToken], Type[SpanToken]]
ShapeArg = Union['Shape', TokenClassType]


class Shape:
    """
    Shape is simple tool to validate input tokens in declarative way.

    Currently, there are 4 operations:
        1. contains_one_of(shape_args) - Every input token has to be valid for
            exactly one shape in argument list.

        2. contains_any_of(shape_args) - Every input token has to be valid for
            at least one++ shapes in argument list.

        3. contains_all_of(shape_arg) - Input token's content has to
            contain only tokens type from argument.

        4. contains_not(shape_args) - Input token can not contains
            tokens from argument type.

        5. contains_order(shape_args) - Input token ordering and structure
            has to exactly match shape_args.

    There are also a few usable properties:
        1. required - specific type has to be included in token.
        2. multiple - multiple instances of specific type are allowed.
        4. first - not usable in contains_order() situation because of
            semantics. Basically, property tells that token should be
            first in list.
        5. last - same as one above expect token should be located last.
        6. min(int) - minimum number of occurrences.
        7. max(int) - maximum number of occurrences.
    """

    def __init__(self, clazz: TokenClassType):
        self.parent = clazz
        self.operations: List['ShaperOperation'] = []
        self.reporter: Optional[Reporter] = None

        # flags to proccess children shapes
        self._multiple = False
        self._required = False
        self._first = False
        self._last = False
        self._min: Optional[int] = None
        self._max: Optional[int] = None

    def __repr__(self):
        operations = ", ".join(list(map(lambda x: x.method, self.operations)))
        main = "parent: {}, required: {}, operations: {}".format(
            self.parent, self._required, operations)
        properties = "multiple: {}, required: {}, first: {}, last: {}, min: {}, max: {}".format(
            self._multiple, self._required, self._first, self._last, self._min, self._max
        )
        return main + " " + properties
    """
    Getters and helper functions
    """

    def is_multiple(self):
        return self._multiple

    def is_required(self):
        return self._required

    def is_first(self):
        return self._first

    def is_last(self):
        return self._last

    def has_max(self):
        return self._max

    def has_min(self):
        return self._min

    def _args_to_shapes(self, args: Sequence[ShapeArg]) -> List['Shape']:
        shapes = []
        for arg in args:
            shapes.append(arg if isinstance(arg, Shape) else Shape(arg))
        return shapes

    """
    Validator properties/flags are implemented below
    """

    @property
    def required(self):
        self._required = True
        return self

    @property
    def multiple(self):
        self._multiple = True
        return self

    @property
    def first(self):
        self._first = True
        return self

    @property
    def last(self):
        self._last = True
        return self

    def min(self, num: int):
        self._min = num
        if (num > 1):
            self._multiple = True
        return self

    def max(self, num: int):
        self._max = num
        if (num > 1):
            self._multiple = True
        return self

    """
    Validator actions are implemented below
    """

    def contains_all_of(self, content: TokenClassType):
        shapes = self._args_to_shapes([content])
        self.operations.append(ShaperOperation(self.parent, shapes, "contains_all_of"))
        return self

    def contains_any_of(self, content: List[ShapeArg]):
        shapes = self._args_to_shapes(content)
        self.operations.append(ShaperOperation(self.parent, shapes, "contains_any_of"))
        return self

    def contains_one_of(self, content: List[ShapeArg]):
        shapes = self._args_to_shapes(content)
        self.operations.append(ShaperOperation(self.parent, shapes, "contains_one_of"))
        return self

    def contains_not(self, content: List[TokenClassType]):
        shapes = self._args_to_shapes(content)
        self.operations.append(ShaperOperation(self.parent, shapes, "contains_not"))
        return self

    def contains_order(self, content: List[ShapeArg]):
        shapes = self._args_to_shapes(content)
        self.operations.append(ShaperOperation(self.parent, shapes, "contains_order"))
        return self

    def check(self, token: Union[BlockToken, SpanToken], reporter: Reporter):
        try:
            to_validate = token.children  # type: ignore
        except AttributeError:
            to_validate = []

        self.reporter = reporter
        is_valid = True
        for op in self.operations:
            is_valid &= op.check(to_validate, reporter)

        return is_valid


class ShaperOperation:
    """
    All operations are based on logical bitwise operator AND so execution will not
    stop when some error happen. It means that in result there should be all
    validation logs and check() method should still be able to return boolean value
    as a result.

    Resulting logic: if one rule check has failed, whole check returns False.
    """

    def __init__(self, parent: TokenClassType, shapes: List[Shape], method: str):
        self.parent = parent
        self.shapes = shapes
        self.method = method
        self.reporter: Optional[Reporter] = None

    def _make_error(self, msg: str) -> None:
        if self.reporter is None:
            raise Exception("Reporter cannot be None!")

        self.reporter.make_error(msg)

    def check(self, to_validate: List[TokenType], reporter: Reporter):
        self.reporter = reporter
        if self.method == 'contains_order':
            return self.check_order(to_validate)
        elif self.method == 'contains_all_of':
            return self.check_all_of(to_validate)
        elif self.method == 'contains_any_of':
            return self.check_any_of(to_validate)
        elif self.method == 'contains_one_of':
            return self.check_one_of(to_validate)
        elif self.method == 'contains_not':
            return self.check_not(to_validate)

        raise Exception("Invalid shaper method choosen: '{}'!".format(self.method))

    def check_all_of(self, to_validate: List[TokenType]):
        """
        Tokens from to_validate should match any of self.shapes type
        """
        tokens_unique = list(set(list(map(lambda x: x.__class__, to_validate))))

        # all of should always contain list of exactly one item
        shape = self.shapes[0].parent
        # There should be only one type within contains() operation
        if shape in tokens_unique and len(tokens_unique) == 1:
            return True

        failed_to = list(filter(lambda x: x != shape, tokens_unique))
        self._make_error(
            "Token '{}' should contains only '{}' types but {} was found!".format(
                self.parent.__name__, shape.__name__, _print_tokens(failed_to)))
        return False

    def check_any_of(self, to_validate: List[TokenType]):
        """
        Tokens from self.types have to be included in to_validate
        token without any order specification.
        """
        valid = False if len(to_validate) == 0 else True
        shapes_list = list(map(lambda x: x.parent, self.shapes))
        failed_token_names: List[str] = []
        for token in to_validate:
            if token.__class__ not in shapes_list:
                token_name = token.__class__.__name__
                if token_name not in failed_token_names:
                    failed_token_names.append(token_name)
                valid = False

        if not valid:
            self._make_error((
                "Failed on {} tokens. Every token from {} has to match one of {}!"
            ).format(failed_token_names, self.parent.__name__, _print_shapes(self.shapes)))

        return self._check_properties(to_validate, valid)

    def check_one_of(self, to_validate: List[TokenType]):
        valid = True
        shapes_list = list(map(lambda x: x.parent, self.shapes))
        counter: Optional[TokenClassType] = None
        for token in to_validate:
            token_cls = token.__class__
            if token_cls in shapes_list:
                if counter is not None and counter != token_cls:
                    self._make_error("In token '{}'. Action one_of already assigned shape "
                                     "for '{}' but found also another shape match: {}".format(
                                         self.parent.__name__,
                                         counter.__name__,
                                         token_cls.__name__))
                    valid = False
                else:
                    counter = token_cls

        if counter is None:
            self._make_error("Token '{}' doesn't contain one of {} tokens!".format(
                self.parent.__name__, _print_shapes(self.shapes)))
            valid = False

        return self._check_properties(to_validate, valid)

    def check_not(self, to_validate: List[TokenType]):
        """
        Token from self.shapes are forbidden! If any self.types tokens
        are in document, throw an error!
        """
        shapes_list = list(map(lambda x: x.parent, self.shapes))
        for token in to_validate:
            if token.__class__ in shapes_list:
                self._make_error(
                    "Token '{}' can not contains '{}'!".format(
                        self.parent.__name__, token.__class__.__name__))
                return False

        return True

    def check_order(self, to_validate: List[TokenType]):
        """
        Order and type of Tokens from to_validate should match self.children list
        """
        valid = True
        valid &= self._check_required(to_validate)
        valid &= self._check_multiplicity(to_validate)
        valid &= self._check_min_max(to_validate)
        """
        Check tokens ordering

        1. Merge co-located tokens into one.
        2. Filter current level shapes to contain only types which are also
            contained in tokens.
        3. Perform simple order check.
        """
        ordered_tokens: List[TokenType] = [to_validate[0]]
        for token in to_validate:
            if not isinstance(ordered_tokens[-1], token.__class__):
                ordered_tokens.append(token)

        o_tokens_classes = [t.__class__ for t in ordered_tokens]
        c_filtered = [c.parent for c in self.shapes if c.parent in o_tokens_classes]
        if o_tokens_classes != c_filtered:
            self._make_error("Got wrong tokens order.\nExpected: {},\nGot: {}".format(
                _print_tokens(c_filtered),
                _print_tokens(o_tokens_classes)
            ))
            valid = False

        valid &= self._check_recursively(to_validate)
        return valid

    def _check_properties(self, to_validate: List[TokenType], is_valid: bool):
        is_valid &= self._check_multiplicity(to_validate)
        is_valid &= self._check_required(to_validate)
        is_valid &= self._check_min_max(to_validate)
        is_valid &= self._check_positions(to_validate)
        is_valid &= self._check_recursively(to_validate)
        return is_valid

    def _check_min_max(self, to_validate: List[TokenType]):
        valid = True
        for shape in self.shapes:
            max_ = shape.has_max()
            min_ = shape.has_min()
            matches = list(filter(lambda x: x.__class__ == shape.parent, to_validate))
            if min_ is not None and len(matches) < min_:
                self._make_error(
                    ("Token {} is marked with min({}) property but {} occurrences were found."
                     ).format(shape.parent.__name__, min_, len(matches)))
                valid = False
            if max_ is not None and len(matches) > max_:
                self._make_error(
                    ("Token {} is marked with max({}) property but {} occurrences were found."
                     ).format(shape.parent.__name__, max_, len(matches)))
                valid = False

        return valid

    def _check_multiplicity(self, to_validate: List[TokenType]):
        valid = True
        for shape in self.shapes:
            match = list(filter(lambda x: x.__class__ == shape.parent, to_validate))
            if not shape.is_multiple() and len(match) > 1:
                self._make_error(("Token '{}' was not marked as multiple but was found "
                                  "{} times in '{}' token.").format(
                    shape.parent.__name__, len(match), self.parent.__name__
                ))
                valid = False

        return valid

    def _check_required(self, to_validate: List[TokenType]):
        valid = True
        for shape in self.shapes:
            match = list(filter(lambda x: x.__class__ == shape.parent, to_validate))
            if shape.is_required() and len(match) == 0:
                self._make_error(("Token '{}' marked as required inside "
                                  "'{}' token, but not found.").format(
                    shape.parent.__name__, self.parent.__name__
                ))
                valid = False

        return valid

    def _check_positions(self, to_validate: List[TokenType]) -> bool:
        valid = True
        for shape in self.shapes:
            if shape.is_first():

                first_token = to_validate[0].__class__ == shape.parent
                if not first_token:
                    self._make_error(
                        "Token {} is marked as first but it is not.".format(shape.parent.__name__))
                    valid = False
            if shape.is_last():
                last_token = to_validate[-1].__class__ == shape.parent
                if not last_token:
                    self._make_error(
                        "Token {} is marked as last but it is not.".format(shape.parent.__name__))
                    valid = False

        return valid

    def _check_recursively(self, to_validate: List[TokenType]):
        """
        Recursively run children shapes check method if they are available.

        1. Run through all tokens.
        2. Assign own shapes to token.
        3. If type is checkable, run it's check() method.
        """
        valid = True
        for token in to_validate:
            shapes = list(filter(lambda x: x.parent == token.__class__, self.shapes))
            if len(shapes) > 0 and not shapes[0].check(token, self.reporter):  # type: ignore
                valid = False
        return valid


def _print_shapes(shape_args: List[Shape]):
    template = "[{}\n]"

    arg_strings = ""
    for shape in shape_args:
        arg_strings += "\n  " + shape.parent.__name__

    return template.format(arg_strings)


def _print_tokens(tokens: List[Any]):
    template = "[{}\n]"

    token_strings = ""
    for token in tokens:
        token_strings += "\n  " + token.__name__

    return template.format(token_strings)
