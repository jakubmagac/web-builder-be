from pathlib import Path

from lxml.html import HtmlElement

from it4kt import url
from it4kt.logger import logger


class HtmlToLatex:
    def __init__(self, html: HtmlElement):
        self.html = html

    def convert(self) -> str:
        return self.render_inner(self.html, True)

    def render_inner(self, el: HtmlElement, remove_space=False, escape=True) -> str:
        result = []
        if el.text:
            text = el.text
            if remove_space:
                text = text.strip()
            result.append(self.render_raw_text(text, escape))

        for child in el:
            if not isinstance(child.tag, str):
                continue
            if hasattr(self, 'render_' + child.tag):
                result.append(getattr(self, 'render_' + child.tag)(child))
            else:
                result.append(self.render_inner(child, True, escape))
            if child.tail:
                text = child.tail
                if remove_space:
                    text = text.strip()
                result.append(self.render_raw_text(text, escape))
        return ''.join(result)

    def render_h1(self, el: HtmlElement) -> str:
        inner = self.render_inner(el)
        return f'\\section*{{{inner}}}\n\n'

    def render_h2(self, el: HtmlElement) -> str:
        inner = self.render_inner(el)
        return f'\\subsection*{{{inner}}}\n\n'

    def render_h3(self, el: HtmlElement) -> str:
        inner = self.render_inner(el)
        if 'step__header' in el.classes:
            return f'\\step{{{inner}}}\n\n'
        return f'\\subsubsection*{{{inner}}}\n\n'

    def render_h4(self, el: HtmlElement) -> str:
        inner = self.render_inner(el)
        return f'\\paragraph{{{inner}}}\n\n'

    def render_h5(self, el: HtmlElement) -> str:
        inner = self.render_inner(el)
        return f'\\subparagraph{{{inner}}}\n\n'

    def render_h6(self, el: HtmlElement) -> str:
        inner = self.render_inner(el)
        return f'\\subsubparagraph{{{inner}}}\n\n'

    def render_p(self, el: HtmlElement) -> str:
        return self.render_inner(el) + '\n\n'

    def render_em(self, el: HtmlElement) -> str:
        inner = self.render_inner(el)
        return f'\\textit{{{inner}}}'

    def render_strong(self, el: HtmlElement) -> str:
        inner = self.render_inner(el)
        return f'\\textbf{{{inner}}}'

    def render_code(self, el: HtmlElement) -> str:
        return f'\\texttt{{{self.render_inner(el, True, True)}}}'

    def render_img(self, el: HtmlElement) -> str:
        src = el.attrib['src']
        return f'\n\\includegraphics{{{src}}}\n'

    def render_a(self, el: HtmlElement) -> str:
        inner = self.render_inner(el)
        href = el.attrib['href']
        return f'\\href{{{href}}}{{{inner}}}'

    def render_ul(self, el: HtmlElement) -> str:
        inner = self.render_inner(el, True)
        return f'\\begin{{itemize}}\n{inner}\\end{{itemize}}\n\n'

    def render_ol(self, el: HtmlElement) -> str:
        inner = self.render_inner(el, True)
        return f'\\begin{{enumerate}}\n{inner}\\end{{enumerate}}\n\n'

    def render_li(self, el: HtmlElement) -> str:
        inner = self.render_inner(el)
        return f'  \\item {inner}\n'

    def render_blockquote(self, el: HtmlElement) -> str:
        inner = self.render_inner(el)
        return f'\\begin{{displayquote}}\n{inner}\\end{{displayquote}}\n\n'

    def render_pre(self, el: HtmlElement) -> str:
        if len(el) == 1 and el[0].tag == 'code':
            inner = self.render_inner(el[0], False, False)
            replacers = {
                'markdown': 'md'
            }
            if 'class' in el[0].attrib:
                cls = el[0].attrib['class']
                if cls.startswith('language-'):
                    lang = cls[9:]
                else:
                    lang = 'text'
                lang = replacers.get(lang, lang)
            else:
                lang = 'text'
            return f'\\begin{{minted}}[breaklines]{{{lang}}}\n{inner}\n\\end{{minted}}\n\n'
        else:
            inner = self.render_inner(el, False, False)
            return f'\\begin{{verbatim}}\n{inner}\\end{{verbatim}}\n\n'

    def render_span(self, el: HtmlElement) -> str:
        if 'math' in el.classes:
            return self.render_raw_text(el.text, escape=False)
        else:
            return self.render_inner(el)

    def render_div(self, el: HtmlElement) -> str:
        if 'task' in el.classes:
            return self.render_block(el, 'task', ': ')
        if 'solution' in el.classes:
            return self.render_block(el, 'solution', ': ')
        if 'result' in el.classes:
            return self.render_block(el, 'solution', ': ')
        if 'lecturer' in el.classes:
            return self.render_block(el, 'lecturer', ': ')
        if 'example' in el.classes:
            if el.find_class('example__title'):
                if 'example--wrong' in el.classes:
                    return self.render_block(el, 'titledWrongExample', ': ')
                else:
                    return self.render_block(el, 'titledExample', ': ')
            else:
                if 'example--wrong' in el.classes:
                    return self.render_block(el, 'wrongExample', ': ')
                else:
                    return self.render_block(el, 'example', ': ')
        if 'admonition--note' in el.classes:
            return self.render_block(el, 'note', ': ')
        if 'admonition--warning' in el.classes:
            return self.render_block(el, 'warning', ': ')
        else:
            return self.render_inner(el, True)

    def render_block(self, el: HtmlElement, type: str, after_title='') -> str:
        heading = self.render_inner(el[0])
        content = self.render_inner(el[1], True)
        return f'\\begin{{{type}}}{{{heading}{after_title}}}\n{content}\\end{{{type}}}\n\n'

    def render_figure(self, el: HtmlElement) -> str:
        img = el.find('img')
        if img is None:
            return ''
        caption = el.find_class('figure__caption')
        if len(caption):
            caption_text = self.render_inner(caption[0])
        else:
            caption_text = ''
        src = img.attrib['src']
        if src.endswith('.svg'):
            logger.warning(
                "Latex doesn't support .svg images! "
                "Please replace any svg image with some alternative format.")
        path = url.relativize(Path('.'), src)
        return (
            f'\\begin{{figure}}[H]\n'
            f'  \\centering\n'
            f'  \\includegraphics[width=\\textwidth,height=\\textheight,keepaspectratio]'
            f'{{{path}}}\n'
            f'  \\caption{{{caption_text}}}\n'
            f'\\end{{figure}}\n\n'
        )

    def render_table(self, el: HtmlElement) -> str:
        first_line = el.find('.//tr')
        align = ''
        for col in first_line.getchildren():
            if col.get('style') == 'text-align:right':
                align += 'r'
            elif col.get('style') == 'text-align:center':
                align += 'c'
            else:
                align += 'l'
        inner = self.render_inner(el, True)
        return (
            f'\\begin{{center}}\n'
            f'  \\begin{{tabular}}{{{align}}}\n'
            f'{inner}'
            f'  \\end{{tabular}}\n'
            f'\\end{{center}}\n\n'
        )

    def render_thead(self, el: HtmlElement) -> str:
        inner = self.render_inner(el, True)
        return inner + '    \\hline\n'

    def render_tr(self, el: HtmlElement) -> str:
        cols = [self.render_inner(col, True) for col in el.getchildren()]
        inner = ' & '.join(cols)
        return f'    {inner} \\\\\n'

    def render_th(self, el: HtmlElement) -> str:
        return self.render_inner(el)

    def render_td(self, el: HtmlElement) -> str:
        return self.render_inner(el)

    SIMPLE_ESCAPES = ['#', '$', '%', '&', '_', '{', '}']

    def render_raw_text(self, text: str, escape=True) -> str:
        if escape:
            text = text.replace('\\', '\\textbackslash')
            for ch in self.SIMPLE_ESCAPES:
                text = text.replace(ch, '\\' + ch)
            return (text
                    .replace('^', '\\textasciicircum{}')
                    .replace('~', '\\textasciitilde{}')
                    .replace('"', '"{}')
                    .replace('\\textbackslash', '\\textbackslash{}'))

        return text
