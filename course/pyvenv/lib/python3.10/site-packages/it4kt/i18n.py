from typing import Any, List, MutableMapping, Optional, Tuple

from it4kt.logger import logger
from pathlib import Path
import yaml


LANGUAGES_KEY = "languages"
FALLBACK_KEY = "fallback"

FormatType = str


class I18n:
    def __init__(self):
        self.translations = {}  # list of avalaiable strings to translate
        self.language = "sk"  # language, which is set
        self.languages = ["sk"]  # will be overriden by i18n parser
        self.default_lang = "sk"  # will be overriden by i18n parser
        self.fallback_lang: Optional[str] = None  # fallback is not required
        self._warning_stack: List[str] = []  # initialize log stack

        self._format_methods = {
            "lowercase": lambda w: w.lower(),
            "uppercase": lambda w: w.upper(),
            "capitalize": lambda w: w.capitalize,
        }  # list of available formatting methods

        self.path = I18nPathManager(self)
        self.parser = I18nParserManager(self)

    def change_language(self, language: str):
        if language not in self.languages:
            logger.critical(
                f"Language {language} was set but is not available in configuration language list.")
        self.language = language

    def _use_formatter(self, word: str, maybe_format: FormatType):
        formatter = self._format_methods.get(maybe_format)
        if formatter is None:
            logger.error(
                f"formatter '{maybe_format}' was not found. "
                f"Allowed formatters are {self._format_methods}")
            return word
        return formatter(word)

    def t(self, t_key: str, formats: Optional[List[FormatType]] = None):
        *namespaces, keyword = t_key.split(":")
        if len(namespaces) == 0:
            self._add_warning(
                f"Following translation string has no namespace: '{keyword}'")
            return keyword

        translated_word = self._t_for_language(self.language, namespaces, keyword)

        if translated_word is None:
            self._add_warning(
                f"translation string for '{t_key}' was not found. "
                f"I18n will use fallback string or default language '{self.default_lang}'")
            translated_word = self._t_for_language(self.default_lang, namespaces, keyword)

            if translated_word is None:
                return keyword

        if formats:
            for formatter in formats:
                translated_word = self._use_formatter(translated_word, formatter)

        return translated_word

    def _t_for_language(self, language, namespaces, keyword):
        translation_location = self.translations[language]
        for ns_key in namespaces:
            translation_location = translation_location[ns_key]
        translated_word = translation_location.get(keyword, None)
        return translated_word

    def t_from_config(self, maybe_t_dict: Any):
        if not isinstance(maybe_t_dict, MutableMapping):
            return maybe_t_dict

        translated_text = maybe_t_dict.get(self.language)
        if translated_text is None:
            translated_text = maybe_t_dict.get(self.default_lang)

        if translated_text is None:
            logger.error(
                f"No translation was found for course config '{maybe_t_dict}' "
                f"for language '{self.language}' or default language.")
        return translated_text

    def _add_warning(self, msg: str):
        if msg not in self._warning_stack:
            self._warning_stack.append(msg)

    def print_warnings(self):
        for msg in self._warning_stack:
            logger.warning(msg)


class I18nParserManager:
    def __init__(self, i18n: I18n):
        self._i18n = i18n

    def read_course(self, course_config: dict):
        try:
            self._i18n.languages = course_config[LANGUAGES_KEY]
            if not isinstance(self._i18n.languages, list):
                raise KeyError()
            # first in languages is default
            self._i18n.default_lang = self._i18n.languages[0]
            self._i18n.fallback_lang = course_config.get(FALLBACK_KEY)
            if self._i18n.fallback_lang and self._i18n.fallback_lang not in self._i18n.languages:
                logger.critical(
                    f"Course fallback language was set to '{self._i18n.fallback_lang}', "
                    f"but languages list is '{self._i18n.languages}'")
        except KeyError:
            logger.critical(
                f"Missing '{LANGUAGES_KEY}' key in course i18n config or "
                "it's value is not a list.")

    def _read_strings(self, translations: MutableMapping, origin: str):
        languages: List[str] = []
        for lang, values in translations.items():
            if lang not in languages:
                # create empty language dict if it doesn't exist
                if self._i18n.translations.get(lang) is None:
                    self._i18n.translations[lang] = {}
                languages.append(lang)
            if values is not None:
                self._i18n.translations[lang][origin] = values

        return languages

    def read_namespaces(self, builder_paths: List[Tuple[str, Path]]):
        """ Method reads one or multiple translation file list as namespaces. """
        for origin, b_path in builder_paths:
            translations = self._read_yaml_strings(b_path)
            languages = self._read_strings(translations, origin)
            missing = set(self._i18n.languages) - set(languages)
            if len(missing) > 0:
                logger.critical(
                    f"Following course language/s are missing in '{b_path}' file: {missing}")

    def _read_yaml_strings(self, path: Path):
        raw_data = yaml.safe_load(path.read_text(encoding="utf-8"))
        if raw_data is None:
            logger.critical(
                f"Failed to read translation file from yaml file at '{path}'.")
        return raw_data


class I18nPathManager:
    def __init__(self, i18n: I18n):
        self._i18n = i18n

    def localize(self, path: Path) -> Optional[Path]:
        # get default file path, e.g. 'index.md'
        default_path = self.remove_language_suffix(path)
        # get currently parsed language suffix, e.g. when i18n.language is 'sk' we get 'index.sk.md'
        language_path = self.add_language_suffix(default_path)
        if language_path.exists():
            # the most ideal situation is when translated file, e.g. 'index.sk.md', does exist.
            return language_path

        # if we didn't find a file there is still posibility that fallback_lang is set.
        fallback_lang = self._i18n.fallback_lang
        if fallback_lang is not None:
            # get fallback path, so if builder's lang is set to 'ru' and fallback is 'en'
            # we will try to find 'index.en.md'.
            fallback_path = self.add_language_suffix(
                default_path, fallback_lang)
            if fallback_path.exists():
                return fallback_path

        # if there is any default file for 'path' then use it.
        if default_path.exists():
            # it this is the case, we can try to provide default file
            return default_path

        # there is no translation option for featured path.
        return None

    def localize_dir(self, path: Path) -> List[Path]:
        """ Method should run every path in directory and return list
            of usable paths for current language. It should also take
            care of default_lang files and fallback language.
        """
        resolved_files: List[str] = []
        file_list: List[Path] = []

        # run through whole processed directory
        for possible_path in path.iterdir():
            # default language file path
            default_path = self.remove_language_suffix(possible_path)
            if str(default_path) in resolved_files:
                # skip, if we already registered file.
                continue

            # get best possible translation path
            translated_path = self.localize(possible_path)
            if translated_path is None:
                continue

            # append default_path to prevent duplications
            resolved_files.append(str(default_path))
            # append translated path to final list
            file_list.append(translated_path)

        return file_list

    def add_language_suffix(self, path: Path, exact_lang: Optional[str] = None) -> Path:
        """ Warning: if file is already suffixed it is not going to replace suffix!

            From e.g.:
                - 'index.xml' method will make 'index.{lang_code}.xml'
                - 'index.en.xml' method with any language set will return just 'index.en.xml'
        """
        if exact_lang is None:
            exact_lang = self._i18n.language

        path_suffixes = path.suffixes
        if len(path_suffixes) < 1:
            # there is no suffix at all
            return path
        if path_suffixes[0][1:] in self._i18n.languages:
            # file already has any language suffix from i18n.languages options
            return path

        # add suffix before all other sufixes
        translated_path = str(path).replace(
            "".join(path_suffixes),
            ".{0}{1}".format(exact_lang, "".join(path_suffixes)))
        return Path(translated_path)

    def remove_language_suffix(self, path: Path) -> Path:
        """
            From e.g.:
                - 'index.en.xml' method will make 'index.xml'
                - 'index.xml' method will return just 'index.xml'
        """
        path_suffixes = path.suffixes
        if len(path_suffixes) < 2:
            # if not in 'index.sk.md' format
            return path
        if path_suffixes[0][1:] not in self._i18n.languages:
            # if parsed language is not in available langagues list
            return path

        # remove language suffix
        clear_suffix = path_suffixes[1:]
        # create path without language suffix
        new_path = str(path).replace(
            "".join(path_suffixes), "".join(clear_suffix))
        return Path(new_path)
