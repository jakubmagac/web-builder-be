import re
from pathlib import PurePath
from typing import Optional

import pkg_resources
from lxml import etree, html
from lxml.html import fragment_fromstring

from it4kt import i18n
from it4kt.cache import CachingReader
from it4kt.filesystem import Node
from it4kt.kpimark import Kpimark
from it4kt.logger import logger
from it4kt.model import Page, SlidePage
from it4kt.shower import ShowerMark


class KpimarkReader(CachingReader):
    """
    KPIMarkReader class serves as bridge between `it4kt-builder`
    and KPIMark parser.

    Principle: Give Markdown and get filled Page element.

    Document type can have following values:
        - page - no validation at all
        - scenario - validate by scenario scheme
        - subject_info - validate by subject_info scheme

    Validation can have following values:
        1. strict - strict validation checks with errors
        2. None   - no validation at all
    """

    def __init__(self, document_type, validation="strict"):
        super().__init__()
        self.kpimark = Kpimark(document_type, validation)

    def cacheable_read(self, path: Node) -> Page:
        page = Page(path.path)
        raw_text = path.content_path.read_text(encoding="utf-8")

        self.kpimark.reset()
        page.element_tree = self.read_kpimark(raw_text, page, path)

        page.title = self.kpimark.title
        page.subtitle = self.kpimark.subtitle
        if self.kpimark.week is not None:
            page.week = self.kpimark.week
        else:
            page.week = week_from_filename(path.path)

        if self.kpimark.publication_week:
            page.publication_week = self.kpimark.publication_week

        return page

    def read_kpimark(self, text: str, page: Page, path: Node) -> str:
        converted_text = self.kpimark.render_html(text, path.content_path)
        return fragment_fromstring(converted_text)


class ShowerSlidesReader(CachingReader):
    def cacheable_read(self, path: Node) -> SlidePage:
        text = path.content_path.read_text(encoding="utf-8")
        page = SlidePage(path.path)
        md = ShowerMark()
        html = md.render(text)
        tree = fragment_fromstring('<div class="unwrap">' + html + '</div>')
        page.element_tree = tree
        self._fill_meta(path, page, md.meta)
        return page

    def _fill_meta(self, path: Node, page: SlidePage, meta: dict) -> None:
        page.title = meta.get('title', "")
        page.subtitle = meta.get('subtitle', "")
        if 'week' in meta:
            page.week = meta.get('week')
        else:
            page.week = week_from_filename(path.path)
        if 'publication-week' in meta:
            page.publication_week = meta['publication-week']
        if 'aspect-ratio' in meta:
            page.aspect_ratio = meta['aspect-ratio']
        if 'theme' in meta:
            page.theme = meta['theme']


class XMLReader(CachingReader):
    def __init__(self, template: str):
        super().__init__()
        self.template = template

    def cacheable_read(self, path: Node) -> Page:
        page = Page(path.path)
        with path.content_path.open('rb') as f:
            tree = etree.parse(f)
            page.title = tree.findtext('{*}title')
            page.subtitle = tree.findtext('{*}subtitle')
            root = tree.getroot()

            # Special case for subject_info
            if root.tag == '{http://kpi.fei.tuke.sk/practices}subjectInfo':
                template = 'subject_info.xsl'
            else:
                template = self.template

            if 'week' in root.attrib:
                page.week = int(root.get('week'))
            else:
                page.week = week_from_filename(path.path)
            if 'publication-week' in root.attrib:
                page.publication_week = int(root.get('publication-week'))

            xml_tree = transform_with_xslt(tree, template, lecturer_mode=True)
            page.element_tree = xml_to_html_tree(xml_tree)

        return page


class XMLScenarioReader(XMLReader):
    def __init__(self):
        super().__init__('scenario.xsl')


def transform_with_xslt(tree, xsl, lecturer_mode) -> etree._ElementTree:
    with pkg_resources.resource_stream('it4kt', 'xsl/' + xsl) as f:
        xslt_tree = etree.parse(f)
        transform = etree.XSLT(xslt_tree)
        try:
            return transform(tree, language=etree.XSLT.strparam(i18n.language),
                             lecturerMode=boolean_to_xsl_value(lecturer_mode))
        except etree.LxmlError:
            logger.error(transform.error_log)


def xml_to_html_tree(xml_tree):
    html_tree = html.fragment_fromstring(str(xml_tree))
    remove_xml_namespaces(html_tree)
    return html_tree


def remove_xml_namespaces(html_tree):
    for attrib in html_tree.keys():
        if attrib.startswith('xmlns:'):
            del html_tree.attrib[attrib]


def boolean_to_xsl_value(value):
    if value:
        return "true()"
    else:
        return "false()"


def week_from_filename(path: PurePath) -> Optional[int]:
    """Get week number from file name."""
    match = re.match(r'^\d+', path.name)
    if match:
        return int(match.group(0))
    else:
        return None
