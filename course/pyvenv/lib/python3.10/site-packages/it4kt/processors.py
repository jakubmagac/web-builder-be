from abc import ABC, abstractmethod
from pathlib import PurePath
from typing import Optional, Tuple, List, Iterable

from it4kt import env, model
from it4kt.filesystem import Node
from it4kt.logger import logger


class Reader(ABC):
    @abstractmethod
    def read(self, path: Node) -> Optional[model.Page]:
        pass


class Writer(ABC):
    @abstractmethod
    def write(self, course: model.Course, path: Node) -> None:
        pass


Patterns = List[Tuple[str, Optional[Reader], Optional[Writer]]]


class Processor:
    def __init__(self, path: PurePath, pages: Patterns, exclude_dirs: Iterable[PurePath] = ()):
        self.path = env.content_dir / path
        self.readers, self.writers = split_readers_writers(pages)
        self.exclude_dirs = exclude_dirs

    def read(self) -> List[model.Page]:
        if not self.path.exists():
            return []

        pages = []
        entry_relative_path = self.path.relative_to(env.content_dir)
        node = env.fs.find(entry_relative_path)
        if node.is_file():
            logger.critical("Following path is not a directory '{}'".format(node))
        for entry in node.children():
            reader = self._find_reader(entry.path)
            if reader is not None:
                page = reader.read(entry)
                if page is not None:
                    pages.append(page)
        return pages

    def write(self, course: model.Course) -> None:
        if not self.path.exists():
            return None

        entry_relative_path = self.path.relative_to(env.content_dir)
        node = env.fs.find(entry_relative_path)
        if node.is_file():
            logger.critical("Following path is not a directory '{}'".format(node))
        for entry in node.children():
            if entry.path in self.exclude_dirs:
                continue
            writer = self._find_writer(entry)
            if writer is not None:
                writer.write(course, entry)

    def _find_reader(self, path):
        for glob, reader in self.readers:
            if path.match(glob):
                return reader

    def _find_writer(self, node: Node):
        for glob, writer in self.writers:
            if node.path.match(glob):
                return writer


def split_readers_writers(patterns):
    """Split a list of patterns with readers and writers into separate lists
    and eliminate None.
    """
    readers = [(p, r) for p, r, w in patterns if r is not None]
    writers = [(p, w) for p, r, w in patterns if w is not None]
    return readers, writers
