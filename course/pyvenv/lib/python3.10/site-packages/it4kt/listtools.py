"""Useful utilities for working with lists and other sequences."""
from collections.abc import Iterable


def split_with(predicate, elements):
    """Split a list into sublists based on a predicate.
    Each element matching the predicate starts a new sublist, for example:

    >>> split_with(lambda x: x % 3 == 0, range(10))
    [[0, 1, 2], [3, 4, 5], [6, 7, 8], [9]]
    """
    groups = []
    for element in elements:
        if predicate(element):
            groups.append([element])
        else:
            if not groups:
                groups.append([])
            groups[-1].append(element)
    return groups


def partition_with(predicate, elements):
    """Partition a list based on the first element matching the predicate.
    Return a tuple with parts before the matched element and after it.

    >>> partition_with(lambda x: x==3, [1, 2, 3, 4, 5])
    ([1, 2], [4, 5])
    >>> partition_with(lambda _: True, [1, 2, 3, 4, 5])
    ([], [2, 3, 4, 5])
    >>> partition_with(lambda x: x==6, [1, 2, 3, 4, 5])
    ([1, 2, 3, 4, 5], [])
    """
    i = 0
    for i, element in enumerate(elements):
        if predicate(element):
            break
    else:
        i += 1
    return elements[:i], elements[i+1:]


def concat(lists):
    """Concat a list of lists.
    If some items are not iterable, they are just copied into a new list.

    >>> concat([[1, 2, 3], 4, [5], range(6, 10), [[10], 11]])
    [1, 2, 3, 4, 5, 6, 7, 8, 9, [10], 11]
    """
    result = []
    for item in lists:
        if isinstance(item, Iterable):
            result.extend(item)
        else:
            result.append(item)
    return result
